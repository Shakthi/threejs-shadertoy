{"Shader":{"ver":"0.1","info":{"id":"XslyRH","date":"1487071088","viewed":2237,"name":"Terrain Lattice","username":"Shane","description":"A hybrid point-lit, flat-shaded terrain with a mesh structure on it.","likes":60,"published":3,"flags":0,"tags":["noise","grid","terrain","lines","mesh"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/*\n\n    Terrain Lattice\n    ---------------\n\n\tThis is a raymarched heightmap subdivided into grid squares, which are each subdivided\n\tinto two triangles to emulate the flat shaded look. It's been done before, so just to \n\tbe different, I put a mesh on top... It seemed like a good idea at the time. :)\n\n    There are two ways to render flat grid squares. One is to linearly interpolate between\n\tthe height values of all four vertices to produce a quad that looks flat on account of\n    its straight edge joins. The other is to split the quad into two triangles and linearly \n\tinterpolate between the three verticies of each of those. I tried both methods, but \n\tliked the look of the genuinely flat-planed triangles more.\n\n    A flat shaded triangle render usually requires a barycentric approach, but since the\n\tgrid triangles are essentially half squares, it's possible to use, vector \n\tperpendicularity, symmetry, etc, to cut down on the calculations considerably.\n\n\tThe extra cycles were used to render the mesh. I originally rendered the diagonal rods \n\talso, but it made things look a little too busy, so I've left them out. Rendering straight \n\tcapsule-like tubes along grid seams can also be expensive, but it was possible to cut \n\tcorners there as well, so to speak.\n\n\tAnyway, this was just a practice run for a more ambitious example I have in mind. By\n\tthe way, I have a simplex grid version as well that I'll put up later.\n    \n\n\tOther examples:\n    \n\t\/\/ Simple, and really nicely lit.\n    Triangulator - nimitz\n\thttps:\/\/www.shadertoy.com\/view\/lllGRr   \n\t\n\n\t\/\/ Nice example that takes an intuitive vectorized approach.\n\tRay Marched Mesh Terrain - Flyguy\n\thttps:\/\/www.shadertoy.com\/view\/ltjSRD\n\n*\/\n\n\/\/ Max ray distance.\n#define FAR 40.\n\n\/\/ The point of the exercise was to polygonize the terrain and give it a flat shaded triangulated\n\/\/ appearance, but if you'd prefer to see smooth quads, just uncomment the following:\n\/\/#define SMOOTH_QUAD\n\n\/\/ Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\/\/ 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n\/\/ of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n\/\/ Height map values. Just a couple of animated sinusoidal layers, but you could put anything\n\/\/ here... so long as it's cheap. :)\nfloat hm(in vec2 p){\n    \n    \/\/ Scaling, plus some movement.\n    p = p\/2. + iTime\/4.;\n    \n    \/\/ Layer one.\n    float n = dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159\/2.), vec2(0.25) + .5)*.66;\n    p = p*1.5;  \/\/ Increase frequency.\n  \n    p.xy = mat2(.866025, .5, -.5, .866025)*p.xy; \/\/ Rotate.\n    \n    \/\/ Add another layer.\n    n += dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159\/2.), vec2(0.25) + .5)*.34;\n    \n    return n; \/\/ Range [0, 1]... hopefully. :)\n\n}\n\n\/\/ Used to scale the grid without having to move the camera.\n#define scale 2. \nvec3 hVal; \/\/ Global variable to hold the three height values for reuse.\n\n\/\/ The terrain - tesselated in a flat-grid triangle-pair fashion... Needs rewording. :D\nfloat triTerrain(vec2 p){ \n\n    \n    p *= scale; \/\/ Scaling.\n    \n    vec2 ip = floor(p); \/\/ Integer value. Used for the unique corner height values.\n    p -= ip; \/\/ Fractional grid value.\n \n    \n    \/\/p *= p*(3.-2.*p); \/\/ Weird Gouraud-looking triangles, or smooth quad.\n     \n    \n    \/\/ The barycentric coordinates, so to speak, and the corresponding height value.\n    \/\/ For those of you familiar with the process, you may note that there are far \n    \/\/ fewer operations than usual.\n   \n    float s = step(1., p.x + p.y); \/\/ Determines which side of the diagonal we're on.\n    \n    \/\/ Storing the heights at the three triangle vertices. Normally, it wouldn't be\n    \/\/ necessary, but we're reusing them to render the mesh.\n    hVal = vec3(hm(ip+s), hm(ip + vec2(1, 0)), hm(ip+vec2(0, 1)));\n    \n    #ifdef SMOOTH_QUAD\n    \/\/ A simple, interpolated quad. It's not really flat, but the edge-joins are straight,\n    \/\/ so it looks that way. Because the mesh is set up on triangle logic, there two\n    \/\/ extra height values. Normally, you'd only need one extra.\n    return mix(mix(hm(ip), hVal.y, p.x), mix(hVal.z, hm(ip+1.), p.x), p.y);\n    #else\n    \/\/ Barycentric setup: This is a very trimmed down version of the generalized barycentric\n    \/\/ calculations that involve cross-products, and so forth. Without going into detail, I'm\n    \/\/ sure you could imagine that three points in space can be used to generate a plane \n    \/\/ equation via cross products and such, and the fractional grid points could be used in\n    \/\/ unison with the vertice coordinates to determine the exact coordinate on the plane, or\n    \/\/ the height value at that coordinate.\n    \/\/\n    \/\/ Anyway, the grid triangles are shaped in such a way that a lot of the operations cancel \n    \/\/ out, and the lines below are the result. You could just use them. However, if you require\n    \/\/ more information, look up a few barycentric coordinate examples.\n    \/\/\n    vec3 b = abs(vec3(1.0 - p.x - p.y, p.x - (p.x - p.y + 1.)*s, p.y - (p.y - p.x + 1.)*s));\n    \n    \/\/ The linearly interpolated triangle height.\n    return dot(b, hVal);\n    #endif\n    \n\/* \n\n    \/\/ Triangulating across the other diagonal. Handy, if you want to make patterns.\n    float s = step(p.x, p.y);\n    hVal = vec3(hm(ip), hm(ip + vec2(1. - s, s)), hm(ip+1.));\n\n    \/\/return mix(mix(hVal.x, hm(ip+vec2(1, 0)), f.x), mix(hm(ip+vec2(0, 1)), hVal.z, f.x),f.y);\n\n    vec3 b = abs(vec3(1. - (1. - s)*p.x - p.y*s, (1.-2.*s)*(p.x - p.y), p.x*s + p.y*(1. - s)));\n    \n    return dot(b, hVal);\n*\/\n   \n \n}\n\n\/\/ The flat shaded terrain and the mesh.\nfloat map(vec3 p){\n    \n    \n    float ter = triTerrain(p.xz); \/\/ The terrain.\n \n    const float hPert = .125; \/\/ Terrain height perturbation.\n    float fl = p.y  + (.5-ter)*hPert;\/\/*.25; \/\/ Adding it to a flat plane.\n\n\n    hVal = hVal*hPert - .025; \/\/ Rescaling the height values to match the terrain perturbation.\n    \n    \/\/ The grid boundary railings. As usual, the code looks more complicated than it is. Basically, we're\n    \/\/ positioning four tubes around the grid boundaries. The Y-value is just a height interpolation\n    \/\/ from one vertice to the adjoining one. The \"abs\" business is just a cheap trick to stack the \n    \/\/ railings on top of one another without having to render another four tubes. \n    vec3 q = p;\n    q.xz = fract(q.xz*scale); \/\/ Break space into squares along the XZ plane.\n        \n    \/\/ Tubes on the left and right boundaries.\n    float ln = length(vec2(q.x, abs(q.y - hVal.x -(hVal.z - hVal.x)*q.z - .125) -.125)*vec2(1.\/scale, 1));\n    ln = min(ln, length(vec2(q.x - 1., abs(q.y - hVal.y - (hVal.x - hVal.y)*q.z - .125) - .125)*vec2(1.\/scale, 1)));\n\n    \/\/ Tubes on the bottom and top boundaries.\n    ln = min(ln, length(vec2(abs(q.y - hVal.x - (hVal.y - hVal.x)*q.x - .125) -.125, q.z)*vec2(1, 1.\/scale)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.z - (hVal.x - hVal.z)*q.x - .125) -.125, q.z - 1.)*vec2(1, 1.\/scale)));\n\n    \/\/ The diagonal tube lines. Makes things look too busy, but comment them out, if you feel like it.\n    \/\/vec2 diag = vec2(q.x + q.z - 1., abs(q.y - hVal.z - (hVal.y - hVal.z)*q.x- .125) -.125);\/\/*.7071;\n    \/\/ln = min(ln, length((diag)*vec2(1.\/scale, 1)));\n        \n    \n\/*    \n    \n    \/\/ If you wanted to use the reverse diagonal on the triangulation. See the comments in the \n    \/\/ \"triTerrain\" function first.\n    \n    ln =   length(vec2(q.x, abs(q.y - hVal.x - (hVal.y - hVal.x)*q.z - .125) -.125)*vec2(1.\/scale, 1));\n    ln = min(ln, length(vec2(q.x - 1., abs(q.y - hVal.y - (hVal.z - hVal.y)*q.z - .125) -.125)*vec2(1.\/scale, 1)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.x - (hVal.y - hVal.x)*q.x - .125) -.125, q.z)*vec2(1, 1.\/scale)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.y - (hVal.z - hVal.y)*q.x - .125) -.125, q.z - 1.)*vec2(1, 1.\/scale)));\n\n\n    vec2 diag = vec2(q.x - q.z, abs(q.y - hVal.x - (hVal.z - hVal.x)*q.z- .125) -.125);\/\/*.7071;\n    ln = min(ln, length((diag)*vec2(1.\/scale, 1)));\n*\/         \n   \n    \n    \n    \/\/ Vertical column and the balls. We've calculated another height value offset by half the grid in \n    \/\/ order to draw just one each - instead of four. It's a little hard to explain why but it has to\n    \/\/ do with repetitive cell boundaries.\n    float hgt = hm(floor(p.xz*scale + .5))*hPert - .025;\n    \/\/float hgtZ = hm(floor(p.xz*scale + .5) + vec2(0, 1))*pert - .025;\n    vec2 offXZ = fract(p.xz*scale + .5) - .5;\n    ln = min(ln, max(length(offXZ\/scale), abs(q.y - hgt) - .25));\n\n    \/\/ The metallic balls. Stacked two high using the \"abs\" trick.\n    float sp = length(vec3(offXZ.x, abs(abs(q.y - hgt - .125) - .125), offXZ.y)*vec3(1.\/scale, 1, 1.\/scale));\n    \n    \n    ln -= .04\/scale; \/\/ Line thickness.\n    sp -= .125\/scale; \/\/ Ball thickness.\n    ln = min(ln, sp);\n    \n  \n \n    \/\/ Object ID.\n    objID = step(fl, ln);\n    \n    \n    \/\/ Combining the mesh with the terrain.\n    return min(fl, ln); \/\/smin(fl, ln, .025);\n \n}\n\n \n\n\/\/ Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.; \/\/fract(sin(dot(rd, vec3(7, 157, 113)))*45758.5453)*.1;\n   \n    for (int i=0; i<96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d*.83;  \/\/ Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\/*\n\/\/ Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n\/\/ a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n\/\/ same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 getNormal(in vec3 p, float t)\n{  \n    vec2 e = vec2(-1., 1.)*0.001*min(1. + t, 5.);   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*\/\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(0.002, 0); \/\/vec2(0.002*min(1. + t*.5, 2.), 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); \/\/ Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    \n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/dist += min( h, stepDist ); \/\/ So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, .5);\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    \/\/ I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5\/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n \/= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n\/\/ Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n\/\/ example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \/\/p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += iTime*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    \/\/ A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); \/\/ Putting in some dark space.\n    \n    p = vec3(c*.8, c*.9, c);\/\/vec3(c*c, c*sqrt(c), c); \/\/ Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); \/\/ Mixing in a bit of purple.\n\n}\n\n\/\/ Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z\/36.)*cos(z\/18.); return vec2(s*16., 0.); }\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 lk = vec3(0, -.5, iTime + 1.);  \/\/ \"Look At\" position.\n\tvec3 ro = lk + vec3(0, 2.5, -2.); \/\/ Camera position, doubling as the ray origin.\n \n    \/\/ Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, .75, 2);\/\/ Put it a bit in front of the camera.\n\t\n\t\/\/ Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t\/\/ synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; \/\/ FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    \/\/ \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    \/\/ assuming no normalization is necessary? The only reason I ask is that lots of people do \n    \/\/ normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    \/\/ Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    \/\/ Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= r2( path(lk.z).x\/128. );\n\n    \n\/*       \n    \/\/ Mouse controls.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)\/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n*\/    \n\t \n    \n    \/\/ Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    float svObjID = objID;\n\t\n    \/\/ Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n        \/\/ Edge and edge-factor.\n        \/\/float edge, crv = 1., ef = 4.; \/\/ Curvature variable not used.\n        \n        \/\/ Texture scale factor.\n        float tSize0 = 1.\/2.;\n    \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    \/\/vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \/\/ Texture-based bump mapping. I've left it out for this.\n        \/\/if(svObjID>0.5) sn = texBump(iChannel0, sp*tSize0, sn, .003);\n\t    \n        \n        \/\/ Obtaining the texel color. \n\t    vec3 texCol;   \n\n        \n        if(svObjID>0.5) { \/\/ Terrain texturing.\n            \n            texCol = tex3D(iChannel0, sp*tSize0, sn);\n            \/\/texCol = texture(iChannel0, sp.xz*tSize0).xyz;\n            \/\/texCol *= texCol;\n            texCol = smoothstep(0.0, .5, texCol);\/\/*vec3(1, .9, .8);\/\/\n            \/\/texCol *= triTerrain(sp.xz)*.25 + .75; \/\/ Adds more definition to the squares.\n \n            \/\/ Color some of the squares brown.\n            if(mod(dot(floor(sp.xz*scale), vec2(1, -1)), 5.)>=2.) texCol *= vec3(1, .5, .25);\n            \n                        \n            \/*\n            \/\/ Blinking lights. Too much, I think.\n            float rnd = fract(sin(dot(floor(sp.xz*scale), vec2(141.13, 289.97)))*43758.5453);\n            rnd = sin(rnd*6.283 + iTime)*.5 + .5;\n            if(rnd>.33) texCol *= vec3(1, .5, .25);\n            else { texCol *= 2.;  }\n            \/\/texCol *= mix(vec3(2.), vec3(1, .5, .25), rnd); \/\/ Alternative: Random mix.\n            *\/\n            \n        }\n        else { \/\/ The chrome lattice.\n            \n            texCol = tex3D(iChannel0, sp*tSize0, sn)*.25;\n \n        }\n    \t\n    \t\/\/ Light direction vector.\n\t    vec3 ld = lp-sp;\n\n        \/\/ Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t\/\/ Normalize the light direction vector.\n\t    ld \/= lDist;\n\n        \n        \n        \/\/ Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, 8.);\n    \tfloat ao = cAO(sp, sn); \/\/ Ambient occlusion.\n\t    \n\t    \/\/ Light attenuation, based on the distances above.\n\t    float atten = 1.\/(1. + lDist*lDist*0.05);\n\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; \/\/ Ramping up the diffuse.\n    \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.); \n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n        \n        \n        \/\/ I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        \/\/ to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*2.;\n        if(svObjID>.5) { \/\/ Lowering the terrain settings a bit.\n            env *= .25;\n            spec *= .5;            \n            fre *= .5;\n        }\n        \n\n        \/\/ Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff + 0.25 + vec3(1, .9, .7)*fre) + env + vec3(1, .95, .8)*spec);\n        \n\n        \/\/ Shading.\n        sceneCol *= ao*atten*sh;\n        \n        \n\t\n\t}\n    \n    \/\/ Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    \/\/ the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(.6, .5, 1), vec3(.025, .05, .1), clamp(rd.y + .75, 0., 1.));\/\/vec3(1, .9, .8);\/\/\n    sceneCol = mix(sceneCol, bg, smoothstep(0., .95, t\/FAR));\n    \n    \/\/ Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}}